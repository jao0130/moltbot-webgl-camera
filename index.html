<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Moltbot WebGL Tactical Camera v3.0</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        :root {
            --accent: #00ff41;
            --bg: #000;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: var(--bg); color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }

        #gl-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10; pointer-events: none;
            padding: var(--safe-top) 0 var(--safe-bottom) 0;
        }

        .header {
            padding: 15px 20px; display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
            pointer-events: auto;
        }
        .v-tag { font-family: monospace; font-size: 11px; color: var(--accent); letter-spacing: 1px; }
        .text-btn { font-size: 12px; font-weight: bold; background: rgba(255,255,255,0.15); padding: 8px 14px; border-radius: 6px; }

        .bottom-area {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(20px);
            padding-bottom: calc(var(--safe-bottom) + 15px);
            pointer-events: auto; display: flex; flex-direction: column; align-items: center;
        }

        .filter-nav {
            display: flex; gap: 12px; overflow-x: auto; width: 100%;
            padding: 15px 20px; scrollbar-width: none;
        }
        .filter-nav::-webkit-scrollbar { display: none; }
        .filter-btn {
            padding: 10px 20px; border-radius: 10px;
            background: rgba(255,255,255,0.1); border: 1.5px solid rgba(255,255,255,0.2);
            font-size: 12px; white-space: nowrap; color: #ccc; transition: 0.2s;
        }
        .filter-btn.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }

        .shutter-row {
            width: 100%; display: flex; justify-content: space-around; align-items: center; padding: 10px 0;
        }
        .burst-counter { width: 50px; text-align: center; font-size: 15px; font-family: monospace; color: var(--accent); font-weight: bold; }
        .shutter-outer {
            width: 78px; height: 78px; border-radius: 50%; border: 4px solid #fff;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        .shutter-inner { width: 62px; height: 62px; border-radius: 50%; background: #fff; transition: 0.1s; }
        .shutter-btn:active .shutter-inner { transform: scale(0.85); }

        #gallery-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: none; flex-direction: column; padding: var(--safe-top) 15px var(--safe-bottom) 15px;
        }
        .gallery-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; overflow-y: auto; flex-grow: 1; }
        .gallery-item { position: relative; border-radius: 8px; overflow: hidden; border: 3px solid transparent; }
        .gallery-item.selected { border-color: var(--accent); }
        .gallery-item img { width: 100%; display: block; }

        #flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 1000; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <video id="video" style="display:none" autoplay playsinline muted></video>
    <canvas id="gl-canvas"></canvas>
    <div id="flash"></div>

    <div id="ui-layer">
        <div class="header">
            <div class="text-btn" onclick="toggleCamera()">翻轉鏡頭</div>
            <div class="v-tag" id="res-status">4K MODE</div>
            <div class="text-btn" onclick="openGallery()" id="gallery-trigger" style="display:none">選片</div>
        </div>

        <div class="bottom-area">
            <div class="filter-nav" id="filter-nav"></div>
            <div class="shutter-row">
                <div class="burst-counter" id="burst-count">0/10</div>
                <div class="shutter-outer" onclick="requestCapture()">
                    <div class="shutter-inner"></div>
                </div>
                <div class="text-btn" onclick="clearBurst()">清除</div>
            </div>
        </div>
    </div>

    <div id="gallery-overlay">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px; align-items:center;">
            <h4 style="margin:0;">高解析度選片</h4>
            <div class="text-btn" onclick="closeGallery()">返回</div>
        </div>
        <div class="gallery-grid" id="gallery-grid"></div>
        <div style="display:flex; gap:10px; padding: 20px 0;">
            <button class="text-btn" style="flex:1; background:var(--accent); color:#000;" onclick="saveSelected()">儲存所選</button>
            <button class="text-btn" style="flex:1;" onclick="clearBurst()">捨棄全部</button>
        </div>
    </div>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 position;
    varying vec2 vTexCoord;
    uniform bool uMirror;
    uniform vec2 uTexScale; // 用於修正拉伸 (Cover 效果)
    void main() {
        float x = uMirror ? -position.x : position.x;
        // 修正 UV 座標以維持比例
        vTexCoord = vec2(x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
        vTexCoord = (vTexCoord - 0.5) * uTexScale + 0.5;
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vTexCoord;
    uniform sampler2D uSampler;
    uniform vec2 uResolution;
    
    uniform float uSharpness;
    uniform float uTemperature;
    uniform float uHighlights;
    uniform float uShadows;
    uniform float uContrast;
    uniform float uBrightness;
    uniform float uSaturation;
    uniform float uBrilliance;

    void main() {
        // 防止 UV 越界 (邊緣填黑)
        if (vTexCoord.x < 0.0 || vTexCoord.x > 1.0 || vTexCoord.y < 0.0 || vTexCoord.y > 1.0) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            return;
        }

        vec2 pixelSize = 1.0 / uResolution;
        vec4 center = texture2D(uSampler, vTexCoord);
        
        // 1. Sharpness (High-Res 卷積矩陣)
        if (uSharpness > 0.0) {
            vec4 n = texture2D(uSampler, vTexCoord + vec2(0.0, pixelSize.y));
            vec4 s = texture2D(uSampler, vTexCoord - vec2(0.0, pixelSize.y));
            vec4 e = texture2D(uSampler, vTexCoord + vec2(pixelSize.x, 0.0));
            vec4 w = texture2D(uSampler, vTexCoord - vec2(pixelSize.x, 0.0));
            center = center + uSharpness * (center * 4.0 - n - s - e - w);
        }

        vec3 color = center.rgb;

        // 2. Exposure & Brightness (+20% 增益校準)
        color = color * (1.1 + uBrightness);

        // 3. Temperature (色溫補償)
        color.r += uTemperature * 0.05;
        color.b -= uTemperature * 0.05;

        // 4. Highlights / Shadows (分區映射)
        float luma = dot(color, vec3(0.299, 0.587, 0.114));
        if (luma < 0.4) color += color * uShadows * ((0.4 - luma) / 0.4);
        if (luma > 0.6) color += color * uHighlights * ((luma - 0.6) / 0.4);

        // 5. Brilliance & Contrast
        color = mix(color, pow(color, vec3(1.0 - uBrilliance * 0.3)), 0.5);
        color = (color - 0.5) * (1.0 + uContrast) + 0.5;

        // 6. Saturation
        float gray = dot(color, vec3(0.299, 0.587, 0.114));
        color = mix(vec3(gray), color, 1.0 + uSaturation);

        gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
    }
</script>

<script>
    const canvas = document.getElementById('gl-canvas');
    const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true, antialias: true });
    const video = document.getElementById('video');
    const flash = document.getElementById('flash');
    const burstCountLabel = document.getElementById('burst-count');
    const galleryOverlay = document.getElementById('gallery-overlay');
    const galleryGrid = document.getElementById('gallery-grid');
    const galleryTrigger = document.getElementById('gallery-trigger');
    const resStatus = document.getElementById('res-status');

    let program, texture;
    let currentFacingMode = 'environment';
    let isMirrored = false;
    let burstPhotos = [];
    let shouldCapture = false;

    const presets = [
        { id: 'jp', name: "日系清新", p: { sharpness: 0.3, temp: -0.33, highlights: -0.06, shadows: 0.09, contrast: -0.15, brightness: 0.17, saturation: 0.09, brilliance: 0.12 } },
        { id: 'fuji', name: "港風富士", p: { sharpness: 0.5, temp: 0.15, highlights: 0.15, shadows: -0.10, contrast: 0.08, brightness: 0.32, saturation: 0.04, brilliance: -0.06 } },
        { id: 'orig', name: "ORIGINAL", p: { sharpness: 0, temp: 0, highlights: 0, shadows: 0, contrast: 0, brightness: 0, saturation: 0, brilliance: 0 } }
    ];

    let activePreset = presets[0];

    async function initCamera() {
        if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
        try {
            // 解鎖 iPhone 12 最高解析度
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: currentFacingMode, 
                    width: { ideal: 4032 }, 
                    height: { ideal: 3024 },
                    frameRate: { ideal: 60 }
                }
            });
            video.srcObject = stream;
            await video.play();
            isMirrored = (currentFacingMode === 'user');
            
            // 獲取實際硬體解析度並同步至畫布
            const settings = stream.getVideoTracks()[0].getSettings();
            resStatus.textContent = `${settings.width}x${settings.height}`;
            
            resize();
        } catch (err) { alert("硬體調用失敗"); }
    }

    function initWebGL() {
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, document.getElementById('vs').text);
        gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.getElementById('fs').text);
        gl.compileShader(fs);
        program = gl.createProgram();
        gl.attachShader(program, vs); gl.attachShader(program, fs);
        gl.linkProgram(program); gl.useProgram(program);

        const posBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }

    function resize() {
        // 畫布解析度同步至螢幕物理像素
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render() {
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            
            // 計算 Aspect Ratio 修正 (Object-fit: cover 邏輯)
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = canvas.width / canvas.height;
            let scaleX = 1, scaleY = 1;
            if (videoAspect > canvasAspect) {
                scaleX = canvasAspect / videoAspect;
            } else {
                scaleY = videoAspect / canvasAspect;
            }

            gl.uniform1i(gl.getUniformLocation(program, 'uMirror'), isMirrored);
            gl.uniform2f(gl.getUniformLocation(program, 'uTexScale'), scaleX, scaleY);
            gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
            
            const p = activePreset.p;
            gl.uniform1f(gl.getUniformLocation(program, 'uSharpness'), p.sharpness);
            gl.uniform1f(gl.getUniformLocation(program, 'uTemperature'), p.temp);
            gl.uniform1f(gl.getUniformLocation(program, 'uHighlights'), p.highlights);
            gl.uniform1f(gl.getUniformLocation(program, 'uShadows'), p.shadows);
            gl.uniform1f(gl.getUniformLocation(program, 'uContrast'), p.contrast);
            gl.uniform1f(gl.getUniformLocation(program, 'uBrightness'), p.brightness);
            gl.uniform1f(gl.getUniformLocation(program, 'uSaturation'), p.saturation);
            gl.uniform1f(gl.getUniformLocation(program, 'uBrilliance'), p.brilliance);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            if (shouldCapture) {
                captureFrame();
                shouldCapture = false;
            }
        }
        requestAnimationFrame(render);
    }

    function requestCapture() {
        if (burstPhotos.length >= 10) return;
        flash.style.opacity = '1';
        setTimeout(() => flash.style.opacity = '0', 60);
        shouldCapture = true;
    }

    function captureFrame() {
        // 以原圖解析度導出高品質影像
        canvas.toBlob(blob => {
            burstPhotos.push(blob);
            updateBurstUI();
        }, 'image/jpeg', 1.0);
    }

    function updateBurstUI() {
        burstCountLabel.textContent = `${burstPhotos.length}/10`;
        galleryTrigger.style.display = burstPhotos.length > 0 ? 'block' : 'none';
    }

    function renderFilterButtons() {
        const nav = document.getElementById('filter-nav');
        presets.forEach(item => {
            const btn = document.createElement('button');
            btn.className = 'filter-btn' + (item.id === activePreset.id ? ' active' : '');
            btn.textContent = item.name;
            btn.onclick = () => {
                activePreset = item;
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
            nav.appendChild(btn);
        });
    }

    function openGallery() {
        galleryGrid.innerHTML = '';
        burstPhotos.forEach((blob, i) => {
            const item = document.createElement('div');
            item.className = 'gallery-item selected';
            item.innerHTML = `<img src="${URL.createObjectURL(blob)}">`;
            galleryGrid.appendChild(item);
        });
        galleryOverlay.style.display = 'flex';
    }

    async function saveSelected() {
        for (let blob of burstPhotos) {
            const file = new File([blob], `Tactical_${Date.now()}.jpg`, { type: 'image/jpeg' });
            if (navigator.share) await navigator.share({ files: [file] });
        }
        clearBurst(); closeGallery();
    }

    function clearBurst() { burstPhotos = []; updateBurstUI(); closeGallery(); }
    function closeGallery() { galleryOverlay.style.display = 'none'; }
    function toggleCamera() { currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment'; initCamera(); }

    window.addEventListener('resize', resize);
    renderFilterButtons();
    initWebGL();
    initCamera();
    requestAnimationFrame(render);
</script>
</body>
</html>
